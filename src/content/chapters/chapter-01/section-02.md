# 仮想マシンとコンテナの違い

## 概要

このセクションでは、仮想マシン（VM）とコンテナの違いを理解し、なぜコンテナが多くのユースケースで選ばれるのかを学びます。

## アーキテクチャの違い

### 仮想マシン（VM）とコンテナのアーキテクチャ比較

仮想マシンはハイパーバイザーを使用してハードウェアを仮想化し、各VMが独自のOS（ゲストOS）を持ちます。一方、コンテナはホストOSのカーネルを共有し、プロセスレベルで隔離されます。

![VM vs コンテナのアーキテクチャ比較](/images/diagrams/vm-vs-container.png)

## 詳細な比較

### リソース効率

| 項目 | 仮想マシン | コンテナ |
|------|-----------|----------|
| 起動時間 | 数分 | 数秒 |
| メモリ使用量 | GB単位 | MB単位 |
| ディスク使用量 | 数十GB | 数百MB |
| CPU オーバーヘッド | 大きい | 小さい |

### 起動時間の比較

```bash
# 仮想マシンの起動（例：Vagrantを使用）
$ time vagrant up
# → 通常1〜5分

# コンテナの起動
$ time docker run -d nginx
# → 通常1〜3秒
```

### 隔離レベル

![VM vs コンテナの隔離レベル比較](/images/diagrams/isolation-level.png)

## コンテナの仕組み

### Linux カーネルの技術

コンテナは、Linuxカーネルの以下の機能を活用しています：

#### 1. Namespaces（名前空間）

プロセスに独立した環境を提供します。

| Namespace | 隔離対象 |
|-----------|---------|
| PID | プロセスID |
| NET | ネットワーク |
| MNT | ファイルシステム |
| UTS | ホスト名 |
| IPC | プロセス間通信 |
| USER | ユーザーID |

#### 2. cgroups（Control Groups）

リソース使用量を制限・監視します。

```bash
# コンテナのリソース制限の例
docker run -d \
  --memory="512m" \
  --cpus="0.5" \
  nginx
```

#### 3. Union File System

イメージのレイヤー構造を実現します。

![Union File System のレイヤー構造](/images/diagrams/docker-union-fs.png)

## どちらを選ぶべきか

### コンテナが適しているケース

- マイクロサービスアーキテクチャ
- 高速なスケーリングが必要
- CI/CDパイプライン
- 開発・テスト環境
- 同一OSでの複数アプリケーション実行

### 仮想マシンが適しているケース

- 異なるOSの実行が必要（Windows上でLinux等）
- 強力なセキュリティ隔離が必要
- レガシーアプリケーションの移行
- カーネルレベルのカスタマイズが必要

### 併用するケース

実際のプロダクション環境では、VMとコンテナを併用することも多いです：

![VM + コンテナ ハイブリッド構成](/images/diagrams/docker-hybrid.png)

## パフォーマンス比較の実例

```bash
# 同じnginxサーバーを起動した場合の比較

# VMの場合（概算）
Memory: 1GB〜
Disk: 10GB〜
起動: 60秒〜

# コンテナの場合
$ docker stats nginx-container
CONTAINER   CPU %   MEM USAGE
nginx       0.00%   3.5MB
Disk: 180MB
起動: 1秒
```

## まとめ

| 観点 | 仮想マシン | コンテナ |
|------|-----------|----------|
| 隔離方式 | ハードウェア仮想化 | OS機能による隔離 |
| 起動速度 | 遅い（分単位） | 速い（秒単位） |
| リソース効率 | 低い | 高い |
| ポータビリティ | 限定的 | 高い |
| セキュリティ | 高い | 中程度 |
| 用途 | 強い隔離が必要な場合 | マイクロサービス等 |

次のセクションでは、Dockerのアーキテクチャについて詳しく学びます。
