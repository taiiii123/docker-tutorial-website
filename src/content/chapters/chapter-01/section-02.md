# 仮想マシンとコンテナの違い

## 概要

このセクションでは、仮想マシン（VM）とコンテナの違いを理解し、なぜコンテナが多くのユースケースで選ばれるのかを学びます。

## アーキテクチャの違い

### 仮想マシン（VM）のアーキテクチャ

仮想マシンは、ハイパーバイザーを使用してハードウェアを仮想化し、各VMが独自のOS（ゲストOS）を持ちます。

```
┌─────────┐ ┌─────────┐ ┌─────────┐
│  App A  │ │  App B  │ │  App C  │
├─────────┤ ├─────────┤ ├─────────┤
│ Bins/   │ │ Bins/   │ │ Bins/   │
│ Libs    │ │ Libs    │ │ Libs    │
├─────────┤ ├─────────┤ ├─────────┤
│Guest OS │ │Guest OS │ │Guest OS │  ← 各VMに専用OS
└────┬────┘ └────┬────┘ └────┬────┘
     └──────────┼──────────┘
          ┌─────┴─────┐
          │Hypervisor │  ← ハイパーバイザー
          ├───────────┤
          │ Host OS   │
          ├───────────┤
          │ Hardware  │
          └───────────┘
```

### コンテナのアーキテクチャ

コンテナは、ホストOSのカーネルを共有し、プロセスレベルで隔離されます。

```
┌─────────┐ ┌─────────┐ ┌─────────┐
│  App A  │ │  App B  │ │  App C  │
├─────────┤ ├─────────┤ ├─────────┤
│ Bins/   │ │ Bins/   │ │ Bins/   │
│ Libs    │ │ Libs    │ │ Libs    │
└────┬────┘ └────┬────┘ └────┬────┘
     └──────────┼──────────┘
          ┌─────┴─────┐
          │  Docker   │  ← コンテナエンジン
          │  Engine   │
          ├───────────┤
          │ Host OS   │  ← カーネルを共有
          ├───────────┤
          │ Hardware  │
          └───────────┘
```

## 詳細な比較

### リソース効率

| 項目 | 仮想マシン | コンテナ |
|------|-----------|----------|
| 起動時間 | 数分 | 数秒 |
| メモリ使用量 | GB単位 | MB単位 |
| ディスク使用量 | 数十GB | 数百MB |
| CPU オーバーヘッド | 大きい | 小さい |

### 起動時間の比較

```bash
# 仮想マシンの起動（例：Vagrantを使用）
$ time vagrant up
# → 通常1〜5分

# コンテナの起動
$ time docker run -d nginx
# → 通常1〜3秒
```

### 隔離レベル

```
仮想マシン:
┌─────────────────────────────┐
│ 完全に独立したOS空間         │
│ ・独自のカーネル            │
│ ・独自のネットワークスタック  │
│ ・独自のファイルシステム     │
│ セキュリティ: 高い           │
└─────────────────────────────┘

コンテナ:
┌─────────────────────────────┐
│ プロセスレベルの隔離         │
│ ・カーネル共有              │
│ ・namespace による隔離       │
│ ・cgroups によるリソース制限 │
│ セキュリティ: 中程度         │
└─────────────────────────────┘
```

## コンテナの仕組み

### Linux カーネルの技術

コンテナは、Linuxカーネルの以下の機能を活用しています：

#### 1. Namespaces（名前空間）

プロセスに独立した環境を提供します。

| Namespace | 隔離対象 |
|-----------|---------|
| PID | プロセスID |
| NET | ネットワーク |
| MNT | ファイルシステム |
| UTS | ホスト名 |
| IPC | プロセス間通信 |
| USER | ユーザーID |

#### 2. cgroups（Control Groups）

リソース使用量を制限・監視します。

```bash
# コンテナのリソース制限の例
docker run -d \
  --memory="512m" \
  --cpus="0.5" \
  nginx
```

#### 3. Union File System

イメージのレイヤー構造を実現します。

```
┌───────────────────┐
│ Container Layer   │ ← 書き込み可能
├───────────────────┤
│ Application Layer │ ← 読み取り専用
├───────────────────┤
│ Dependencies      │ ← 読み取り専用
├───────────────────┤
│ Base Image        │ ← 読み取り専用
└───────────────────┘
```

## どちらを選ぶべきか

### コンテナが適しているケース

- マイクロサービスアーキテクチャ
- 高速なスケーリングが必要
- CI/CDパイプライン
- 開発・テスト環境
- 同一OSでの複数アプリケーション実行

### 仮想マシンが適しているケース

- 異なるOSの実行が必要（Windows上でLinux等）
- 強力なセキュリティ隔離が必要
- レガシーアプリケーションの移行
- カーネルレベルのカスタマイズが必要

### 併用するケース

実際のプロダクション環境では、VMとコンテナを併用することも多いです：

```
┌────────────────────────────────────────┐
│             クラウドVM                  │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ │
│  │Container │ │Container │ │Container │ │
│  └──────────┘ └──────────┘ └──────────┘ │
│            Docker Engine                │
└────────────────────────────────────────┘
```

## パフォーマンス比較の実例

```bash
# 同じnginxサーバーを起動した場合の比較

# VMの場合（概算）
Memory: 1GB〜
Disk: 10GB〜
起動: 60秒〜

# コンテナの場合
$ docker stats nginx-container
CONTAINER   CPU %   MEM USAGE
nginx       0.00%   3.5MB
Disk: 180MB
起動: 1秒
```

## まとめ

| 観点 | 仮想マシン | コンテナ |
|------|-----------|----------|
| 隔離方式 | ハードウェア仮想化 | OS機能による隔離 |
| 起動速度 | 遅い（分単位） | 速い（秒単位） |
| リソース効率 | 低い | 高い |
| ポータビリティ | 限定的 | 高い |
| セキュリティ | 高い | 中程度 |
| 用途 | 強い隔離が必要な場合 | マイクロサービス等 |

次のセクションでは、Dockerのアーキテクチャについて詳しく学びます。
